package dx.common.debugging {	import flash.external.ExternalInterface;	import flash.utils.getQualifiedClassName;	import flash.system.Capabilities;	import dx.common.ei;	public class console {		private static var _debug: Boolean = false;		private static var _available: Boolean = false;		private static var _times:Object = {};		public static var exceptionMessage:String = "";		public static var prefix:String = "";		public static function isDebug(b:Boolean):Boolean{			trace("set isDebug:", b)			_debug = b;			_available = ei.available;			if(_available) ExternalInterface.marshallExceptions = true;			return _debug;		}		public static function output(logtype:String, args:Array):void{			if(_debug){				if(_available){					args.unshift('['+prefix+']');					ExternalInterface.call.apply(null, ["console."+logtype].concat(args));				}else{					trace((logtype=="error" ? "[ERROR]" : "") + args.join(" "));				}			}		}		public static function safe(...args):void{			if(_debug){				var sendArgs:Array = ["SAFE"];				for(var i:uint = 0; i< args.length;i++){					if(getQualifiedClassName(args[i]) == "Array"){						for(var k:uint = 0; i< args[i].length;k++){							sendArgs.push(i+":"+args[i][k]);						}					}else if(typeof(args[i]) == "object" && args[i] !== null){						for(var nm:String in args[i]){							sendArgs.push(nm+":"+args[i][nm]);						}					}else{						sendArgs.push(args[i])					}				}				ExternalInterface.call.apply(null, ["console.log"].concat(sendArgs));			}		}		public static function type(thing:*): String {			//log("type::", getQualifiedClassName(thing));			if(type === null) return "NULL";			return getQualifiedClassName(thing);		}		public static function log(...args): void {			trace(args);			output("log", args);		}		public static function debug(...args): void {			output("debug", args);		}		public static function info(...args): void {			output("info", args);		}		public static function warn(...args): void {			output("warn", args);		}		public static var shownOnce:Boolean = false;		public static function error(...args): void {			var errObj:Object			for(var i:uint = 0; i<args.length; i++){				if((args[i]) is Error){					errObj = args[i];					args[i] = " > " + args[i].name+" > "+args[i].message;					break;				}			}			try{				trace("try error")				//output("error", args);				//ExternalInterface.call.apply(null, ["console.error"].concat(args));				if(_available){					trace("EI available, trying...")					if(errObj  && Capabilities.isDebugger){						var stacktrace:String = errObj.getStackTrace();						try{							trace("warn stacktrace");							ExternalInterface.call.apply(null, ["console.warn"].concat([stacktrace])); // error doesn't have line breaks!						}catch(e:Error){							trace("error sending error in console");							_available = false;							dir(stacktrace);						}					}else if(!Capabilities.isDebugger && !shownOnce){						trace("no debug player")						shownOnce = true;						ExternalInterface.call.apply(null, ["console.error"].concat(["Debugging Player not installed - cannot show stack trace"]));					}else{						trace("Problem. errObj:", !!errObj, "Capabilities.isDebugger: ", Capabilities.isDebugger, "shownOnce:", shownOnce);						for(i = 0; i<args.length; i++){							trace("   ", args[i]);						}					}				}else{					trace("[STACK-TRACE]");					dir(errObj.getStackTrace())				}			}catch(e:Error){				trace("Cannot show stack trace; error in ExternalInterface");			}		}		public static function dir(...args): void {			if(_debug && _available){				ExternalInterface.call.apply(null, ["console.dir"].concat(args));			}else if(_debug){				output("log", [ "[" + (args[1] || "OBJECT") + "]" ]);				exceptionMessage = printObject(args[0], "    ");				output("log", [exceptionMessage]);			}		}		public static function time(...args): void {			if(_debug){				if(_available){					ExternalInterface.call.apply(null, ["console.time"].concat(args));				}else{					_times[args[0]] = new Date().getTime();				}			}		}		public static function timeEnd(...args): void {			if(_debug){				if(_available){					ExternalInterface.call.apply(null, ["console.timeEnd"].concat(args));				}else{					trace(args[0]+"::"+(new Date().getTime() - _times[args[0]]));				}			}		}		private static function printObject(o:*, indent:String = null):String{			indent = indent === null ? "" : indent + "    ";			var t:String;			if(type(o) == "Array"){				for(var i:int=0;i<o.length;i++){					t += i +":" +printObject(o[i], indent);				}			}else if(type(o) == "Object"){				t += "\n";				for(var nm:String in o){					t += indent + nm + ":" + printObject(o[nm], indent) ;				}			}else{				return o + "\n";			}			return t+"\n";		}	}}