package dx.common.parse{	import dx.common.debugging.console;	import dx.common.util;	import flash.xml.*;	import flash.utils.getQualifiedClassName;	import flash.net.URLRequest;	import flash.net.URLLoader;	import flash.events.EventDispatcher;	import flash.errors.*;	import flash.events.*;	import flash.errors.IOError;	public class XMLCore{		public var result:Object;		private var arrayNodeNames:Array;		private var textProperty:String = "value";		private var callback:Function;		private var errback:Function;		private var debug:Boolean = false;		private var callbacks:Object = {}		public function XMLCore(options:Object){			callback = options.callback;			if(options.errback) callbacks.errback = options.errback;			if(options.debug) debug = true;			if(options.url){				load(options);			}else if(options.data){				console.log("XML PARSE:", options.data)				console.log("XML",  XML(options.data))				parseComplete(parse(XML(options.data)));			}		}		private function log(... args):void{			if(debug) console.log.apply(console, args);		}		private function newline():void{			log("*");		}		public function load(args:Object):void{			var myXML:XML = new XML();			//console.log("loading xml...", args)			try{				this.textProperty = args.textProperty || "value";				this.arrayNodeNames = args.arrayNodeNames || [];				this.arrayNodeNames.forEach(function(nm:String, i:uint, ar:Array):void{					 // quotes are put around property names so illegal characters or					 //		reserved words will parse and transfer correctly.					//this.arrayNodeNames.push('"' + nm + '"');					arrayNodeNames.push(nm);				}, this);				var myXMLURL:URLRequest = new URLRequest(args.url);				var myLoader:URLLoader = new URLLoader(myXMLURL);				myLoader.addEventListener("ioError", function (e:Event):void {					console.error("-------------->>> LOAD ERROR", e);					if(callbacks.errback) callbacks.errback(e);				});				myLoader.addEventListener("complete", function (event:Event):void{					log("XML Loaded and parsing...")					parseComplete(parse(XML(myLoader.data)));				});			}catch(e:Error){				console.error("-------------->>> XML PARSE ERROR", e);				if(callbacks.errback) callbacks.errback(e);			}		}		public function parseComplete(o:Object):void{			util.pub("xml_complete", o);			callback && callback(o);		}		public function parse(xml:XML):Object{			// wrap XML in a root node, in order to process actual root properties			//console.log("parse xml data", xml)			return this.xmlToObject(new XML("<root></root>").appendChild(xml), "START");		}		public function xmlToObject(node:XML, d:String = ""):Object {			// summary			//		Recursively walks the xml tree			//			d = d == "START" ? "" : d + "    ";			var o:Object = {}, attOb:Object = {};			var value:*, nm:String;			var len:Number = node.children().length();			var n:XML = node.children()[0];			// checking for no children (includes no text)			// if attributes however, return those in an object			if(len == 0){				//log("      N att amt::", node.attributes().length());				if(node.attributes().length()){					log(d+"atts in null node:", node.attributes());					this.mixinAttributes(attOb, node.attributes());					return attOb				}				log(d+"NULL - returning NULL");				return null;			}			//newline();			log(d+node.localName() , " > chil amt", len, " kind:", n.nodeKind(), "one chil:", (len == 1), " is text: ", (n.nodeKind() == "text"), " 1st child att amt::", n.attributes().length())			//log(" chillen nodes:", node.children());			// checking for a text node			//	return the value			if(len == 1 && n.nodeKind() == "text"){				//one node and it's text				value = util.trim(n.toString()); // important! An E4X object, otherwise				log(d+"text = ", value)				log(d+"text atts: ", n.attributes().length(), node.attributes().length())				if(node.attributes().length()){					log(d+"text has atts", node.attributes())					this.mixinAttributes(attOb, node.attributes());					attOb[this.textProperty] = value;					return attOb;				}				return value;			}else{ // node has children				if(node.attributes().length()){					log(d+"--------> ATTTS", mixinAttributes({}, node.attributes()))					this.mixinAttributes(o, node.attributes());				}				for (var i:uint = 0; i < len; i++) {					n = node.children()[i];					// a text node that is a sibling of other, named nodes					// ex: 	<foo>					//			stray					//			<bar>txt</bar>					//		</foo>					if(n.nodeKind() == "text"){						log(d+"stray node");						o[this.textProperty] = n.toString();						continue; // FIXME... this is not consistent with the if-else's below					}					//nm = '"' + n.localName() + '"';					nm = n.localName();					log(d+"node name (",i,"):", nm);					//log(d+"arrayName??", (this.exists(this.arrayNodeNames, nm)));					//log(d+"node name:", n.localName(), "::", n);					// Check for a second instance of an object.					// Convert the previously created object to an array and insert					//	its contents in the first slot. Then add to second slot.					//	NOTE: This will not happen in the case of arrayNodeNames					if(o[nm] && getQualifiedClassName(o[nm])!="Array"){						log(d+"is array:", n, o[nm]);						var _val:Object = util.copy(o[nm]);						//log(d+"convert from array:", nm, "=", o[nm]);						//log(d+"copy val:", _val)						if(nm == null || nm == "null") nm = "value";						o[nm] = [ _val ];						this.arrayNodeNames.push(nm)						//log(d+"copied to array:", o[nm]);						o[nm].push(this.xmlToObject(n, d));						//log(d+"now:", o[nm], o[nm].length);					// Check if exists in arrayNodeNames					//	"arrayNodeNames", when passed to this class,					//	tells the code which nodes are expected to be arrays,					//	even if there is only one instance of that item.					}else if(this.exists(this.arrayNodeNames, nm)){						log(d+"arrayNodeNames:", n, o[nm], o, node);						if( getQualifiedClassName(o[nm])!="Array"){							// this is the first occurence of the array							o[nm] = [];						}						var _val2:Object = this.xmlToObject(n, d);						//log(d+"arrayNodeNames - add to array VAL:", _val2)						//log(d+"arrayNodeNames - add to array NDE:", n)						o[nm].push(_val2);					// Finally, either object or property					//	Object if there are children or attributes					//	Property if "xmlToObject" returns text					}else{						// property (could be an object)						if(nm == null || nm == "null") nm = "value";						o[nm] = this.xmlToObject(n, d);						log(d+"object:", nm, " = ",o[nm]);						o[nm] = util.normalize(o[nm]);						if(n.attributes().length()){							log(d+"multi attz::", n.attributes().length());							if( getQualifiedClassName(o[nm])!="Object"){								log(d+"DON'T MIXIT.")								o[nm] = { value:util.normalize(o[nm]) }								log(d+"obj prop?", nm, "=", o[nm])							}else{								log(d+"**MIXIT", mixinAttributes({}, n.attributes()))							}							this.mixinAttributes(o[nm], n.attributes());						}					}				}			}			return o;		}		private function mixinAttributes(o:Object, atts:XMLList):Object{			// mix atts into given object RETURNS VOID			//			//log("MIXATTS:", atts, atts.length());			for(var i:uint=0,len:uint=atts.length();i<len;i++){				var v:* = atts[i].toString();				if(v == "true") v = true;				if(v == "false") v = false;				o[atts[i].localName().toString()] = util.normalize(v);			}			return o;		}		private function exists(ar:Array, nm:String):Boolean{			//this.dbg.log("EXISTS:");this.dbg.log("      :", nm);this.dbg.log("      :", ar)			if(ar){				return (ar.indexOf(nm) == -1) ? false : true;			}			return false;		}	}}