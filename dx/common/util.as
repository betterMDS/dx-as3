package dx.common {	import flash.utils.ByteArray;	import flash.utils.setTimeout;	import flash.utils.clearTimeout;	import flash.utils.setInterval;	import flash.utils.clearInterval;	import flash.utils.getQualifiedClassName;	import flash.net.navigateToURL;    import flash.net.URLRequest;	import flash.events.MouseEvent;	import dx.common.debugging.console;	import dx.common.StageContainer;	public class util {		private static var _stage:StageContainer;		public static function set stage(s:StageContainer):void{			_stage = s;		}		public static function get stage():StageContainer{			return _stage;		}		//	*** Lang methods *************************************************		public static function className(thing:*):String{			return getQualifiedClassName(thing).split("::")[1];		}		public static function isObject(thing:*):Boolean{			return typeof(thing) == "object" && thing !== null;		}		public static function isArray(thing:*):Boolean{			return getQualifiedClassName(thing) == "Array"			//return isObject(thing) && thing.hasOwnProperty("push");		}		public static function inArray(a:Array, thing:*):Boolean{			for(var i:uint = 0; i < a.length; i++){				if(a[i] === thing) return true;			}			return false;		}		public static function isString(thing:*):Boolean{			return getQualifiedClassName(thing) == "String"		}		public static function each(o:Object, func:Function):void{			if(isArray(o)){				for(var i:uint=0; i<o.length;i++){					func(o[i]);				}			}else{				for(var nm:String in o){					func(o[nm]);				}			}		}		public static function setTimeout(func:Function, ms:uint):uint{			// keeps the context so this function is not super important.			// It's convenient to not have to import the util			return flash.utils.setTimeout(func, ms);		}		public static function clearTimeout(handle:uint):void{			flash.utils.clearTimeout(handle);		}		public static function setInterval(func:Function, ms:uint):uint{			return flash.utils.setInterval(func, ms);		}		public static function clearInterval(handle:uint):void{			flash.utils.clearInterval(handle);		}		public static function mx(m:Object, s:Object, opt:String = ""):Object{			var undef:Boolean = true;			if(/copy/.test(opt)) m = copy(m);			if(/both/.test(opt)) s = copy(s);			if(/noUndef/i.test(opt)) undef = false;			return mix(m, s, undef)		}		public static function mix(m:Object, s:Object, includeUndef:Boolean = true):Object{			for(var nm:String in s){				if(!includeUndef && m[nm] === undefined) continue;				if(s[nm] === null){ //got you bitch!					m[nm] = null;				}else if(typeof(s[nm]) == "object" && s[nm].hasOwnProperty("currentFrame")){					// MovieClip					m[nm] = s[nm];				}else if(typeof(s[nm]) == "object" && !s[nm].hasOwnProperty("push") && s[nm] !== null){					if(typeof(m[nm]) != "object"){						// changing a variable to an object. Kosher?						m[nm] = s[nm];					}else{						try{							m[nm] = util.mix(m[nm], util.copy(s[nm]), includeUndef);						}catch(e:Error){							console.error("Error in util mix:", e);							console.error("error from:", nm, m[nm]);							console.error("error to:", s, "::", s[nm]);						}					}				}else{					// looks like Arrays would fall to here					m[nm] = s[nm];				}			}			return m;		}		//	deep copy without references using ByteArray serialization		public static function copy(o: Object): * {			var ba: ByteArray=new ByteArray();			ba.writeObject(o);			ba.position=0;			return (ba.readObject());		}		//	*** Scope methods *************************************************		public static function hitch(scope: Object, method: String): Function {			var f:Function;			try{				f = scope[method];			}catch(e:Error){				console.error("Error hitchin:", e);				if(e.errorID == 1069){					console.error("Possibly hitching to a private method:  \"", method, "\"" );				}			}			return function(... args): *{				if(f.length != args.length){					console.error("Wrong number of args hitched to \"", method, "\"");				}				return f.apply(scope, args);			}		}		public static var topics:Object = {};		public static function pub(channel:String, value:* = null):Boolean{			if(topics[channel]){				for(var i:uint = 0; i<topics[channel].length; i++){					topics[channel][i](value);				}				return true;			}			return false;		}		public static function sub(channel:String, callback:Function):Array{			if(!topics[channel]){				topics[channel] = [];			}			topics[channel].push(callback);			return [channel, callback];		}		public static function unsub(handle:Array):void{			if(!handle || !handle.length) return;			var channel:String = handle[0];			var func:Function = handle[1];			for(var i:uint = 0; i<topics[channel].length; i++){				if(topics[channel][i] == func){					topics[channel].splice(i, 1);					break;				};			}		}		public static function suball(subs:Array):Array{			var a:Array = [];			for(var i:uint = 0; i<subs.length; i++){				a.push(sub(subs[i][0], subs[i][1]));			}			return a;		}		public static function unsuball(handles:Array):void{			for(var i:uint = 0; i<handles.length; i++){				unsub(handles[i]);			}		}		//*** JS Helper methods EXPERIMENTAL (should go in own class) *************************************************		public static function goUrl(url:String):void{			var request:URLRequest = new URLRequest(url);			try {				navigateToURL(request);			}			catch (e:Error) {				// handle error here				console.error("Error opening url: ", url)			}		}		public static function doJS(js:String):*{			// hm... does not return...			navigateToURL(new URLRequest("javascript:alert('woo hoo, lookie me')"), "_self");		}		//	*** DOM Helper methods *************************************************		public static function actAsFlyout(btn:Object, flyout:Object, onOver:Function, onOut:Function):void{			var flyoutOverHandle:int;			var isOver:Boolean = false;			flyout.buttonMode = true;			flyout.addEventListener(MouseEvent.MOUSE_OVER, function(...a):void{				util.clearTimeout(flyoutOverHandle);				if(!isOver){					isOver = true;					onOver();				}			});			flyout.addEventListener(MouseEvent.MOUSE_OUT, function(...a):void{				util.clearTimeout(flyoutOverHandle);				flyoutOverHandle = util.setTimeout(function():void{					isOver = false;					onOut();				}, 300);			});			btn.addEventListener(MouseEvent.MOUSE_OVER, function(...a):void{				util.clearTimeout(flyoutOverHandle);				if(!isOver){					isOver = true;					onOver();				}			});			btn.addEventListener(MouseEvent.MOUSE_OUT, function(...a):void{				util.clearTimeout(flyoutOverHandle);				flyoutOverHandle = util.setTimeout(function():void{					isOver = false;					onOut();				}, 300);			});			flyout.show = false;		}		public static function centerToContainer(mc:Object, cn:Object = null, debug:Boolean = false):void{			var mw:Number = mc.width;			var mh:Number = mc.height;			var cw:Number = cn == null ? mc.stage.stageWidth  : cn.w || cn.width || cn.stageWidth;			var ch:Number = cn == null ? mc.stage.stageHeight : cn.h || cn.height || cn.stageHeight;			if(cn.defaults && cn.defaults.thickness){				cw -= cn.defaults.thickness*2;				ch -= cn.defaults.thickness*2;			}			mc.x = (cw - mw)/2;			mc.y = (ch - mh)/2;			 if(debug) console.log("centerToContainer", "mc.x:", mc.x, "mc.y:", mc.y, "mc.w:", mw, "mc.h:", mh, "c.x:", cn.x, "c.y:", cn.y, "c.w:", cw, "c.h:", ch)		}		public static function sizeToContainer(mc:Object, cn:Object = null):void{			var o:Object = stage.getStageEvent();			var sh:Number = o.videoHeight;			var sw:Number = o.videoWidth;			var mw:Number = mc.width;			var mh:Number = mc.height;			var cw:Number = cn == null ? sw : cn.w || cn.width || sw;			var ch:Number = cn == null ? sh : cn.h || cn.height || sh;			var ma:Number = mh/mw;			var ca:Number = ch/cw;			if(ma == ca){				// same				mc.width = cw;				mc.height = ch;				mc.x = 0;				mc.y = 0;			}else if(ca > ma){				// cn is taller				mc.width = cw;				mc.x = 0;				mc.scaleY = mc.scaleX;				mc.y = (ch - mc.height)/2;			}else{				// cn is wider				mc.height = ch;				mc.y = 0;				mc.scaleX = mc.scaleY;				mc.x = (cw - mc.width)/2;			}		}		public static function fillToContainer(mc:Object, cn:Object = null):void{			// similar to sizeToContainer, but tries to cover the whole container			var sh:Number = stage.getStageEvent().videoHeight;			var mw:Number = mc.width;			var mh:Number = mc.height;			var cw:Number = cn == null ? mc.stage.stageWidth  : cn.w || cn.width || cn.stageWidth;			var ch:Number = cn == null ? sh : cn.h || cn.height || sh;			var ma:Number = mh/mw;			var ca:Number = ch/cw;			if(ma == ca){				// same				mc.width = cw;				mc.height = ch;				mc.x = 0;				mc.y = 0;			}else if(ca > ma){				// cn is taller				mc.height = ch;				mc.y = 0;				mc.scaleX = mc.scaleY;				mc.x = (cw - mc.width)/2;			}else{				// cn is wider				mc.width = cw;				mc.x = 0;				mc.scaleY = mc.scaleX;				mc.y = (ch - mc.height)/2;			}		}		//	*** String methods *************************************************		public static function strip(txt:String, txtToString:String):String {			var r:RegExp = new RegExp(txtToString, "g");			return txt.replace(r, "");		}		public static function capitalize(s:String):String {			return s.substring(0,1).toUpperCase() + s.substring(1).toLowerCase();		}		public static function urlEscape(s:String):String{			var t:String = "";			for(var i:int=0;i<s.length;i++){				if(s.charCodeAt(i) < 255) t+=s.charAt(i);			}			return escape(t);		}		private static var uidMap:Object = {};		public static function uid(s:String = ""):String{			s = (s || "item") + "_";			if(uidMap[s] === undefined) uidMap[s] = -1;			uidMap[s]++;			return s + uidMap[s];		}		public static function stamp():String{ // maybe if options string passed returns a mapped increment - no arg returns timstamp UID			var r:Function = function():int{				return Math.floor(Math.random()*10)			}			return new Date().getTime() +r() +r() +r() +r();		}		public static function getName(s:String):String{			return s.substring(s.lastIndexOf("/")+1, s.lastIndexOf("."));		}		public static function trim(str:String):String {			return str.replace(/^\s\s*/gi, '').replace(/\s\s*$/gi, '');		}		public static function normalize(val:*, splitCommas:Boolean = false):*{			var i:int = 0;			if( getQualifiedClassName(val) == "String"){				if(val === "true"){					val = true;				}else if(val === "false"){					val = false;				}else if(Number(val) == val){					if(val.substring(0,1) == "0") return val; // prob an ID like 0001					val = Number(val);				}else if(splitCommas && /,/.test(val)){					if(/:/.test(val)){						var o:Object = {};						val = val.split(",");						for(;i<val.length;i++){							var p:Array = val[i].split(":");							o[p[0]] = normalize(p[1]);						}						val = o;					}else{						val = val.split(",");						for(;i<val.length;i++){							val[i] = normalize(val[i]);						}					}				}			}			return val;		}		public static function pad(str:String, amt:uint, addTo:String = "right", char:String = " "):String {			var s:String = "";			for(var i:uint = 0; i< amt; i++){				s += char;			}			return addTo == "right" ? str + s : s + str;		}		public static function tab(str:String, len:uint):String {			var amt:uint = len-str.length;			if(amt<1) return str;			for(var i:uint = 0; i< amt; i++){				str += " ";			}			return str;		}		public static function convertBytes(b:Number, all:Boolean = false):* {			var places:Function = function(n:Number, d:Number):Number{				return Number(n.toFixed(d));			}			var o:Object = {				kb: places(Math.round(b/1024*100000)/100000, 0),				mb: places(Math.round(b/1048576*100000)/100000, 1),				gb: places(Math.round(b/1073741824*100000)/100000, 2)			};			if(all)	return o;			if(o.gb > 1) return o.gb + "GB";			if(o.kb < 1000) return o.kb + "kb";			return o.mb + "MB";		}		public static function fromTimeCode(tc:String):int{			if(!tc) return 0;			var a:Array = tc.split(":");			var secs:int = 0;			secs += parseInt(a[2], 10);			secs += parseInt(a[1], 10) * 60;			secs += parseInt(a[0], 10) * 3600;			return secs;		}		public static function stringTime(ms:Number):String{			if(!ms) return "0";			var s:String = "", hh:Number, mm:Number, ss:Number = ms / 1000;			hh = Math.floor(ss / 3600);            mm = Math.floor((ss - (hh*3600)) / 60);			ss = Math.floor( ss - (hh*3600) - (mm*60) );			ms = ms - (hh*3600000) - (mm*60000) - (ss*1000);			if(hh) s += hh + " hr ";			if(mm) s += mm + " min ";			if(ss) s += ss + " secs ";			if(mm) s += ms + " ms";			if(!s) s = "0";            return s;		}		public static function timeCode(pos:Number, format:String = "mm_ss_ms"):String{			// pos == seconds			// example if using ms, rounded to second:			// util.timeCode(time/1000, "mm_ss")			if (!isNaN(pos)){				var hh_mm_ss_ms:Boolean = format == "hh_mm_ss_ms";				var hh_mm_ss:Boolean = format == "hh_mm_ss";				var mm_ss_ms:Boolean = format == "mm_ss_ms"; // default				var mm_ss:Boolean = format == "mm_ss";				var tc:String, hh:*, mm:*, ss:*, mmss:* = ".0";				if (Math.floor(pos) != pos){					mmss = (((pos - Math.floor(pos)).toString()).substring(1, 3));					pos = Math.floor(pos);				}				//console.log("tiomecode pos:", pos)				hh = Math.floor(pos / 3600);				mm = Math.floor((pos - hh * 3600) / 60);				ss = Math.floor(pos - (hh * 3600) - (mm * 60));				//trace(" hh:" + hh + "  mm" + mm + " ss" + ss + " ms" + mmss);				if (hh < 10){					hh = "0" + hh;				}				if (mm < 10){					mm = "0" + mm;				}				if (ss < 10){					ss = "0" + ss;				}				// always return HH:MM:SS if greater than 1 hour.				if (pos > 3600){					tc = hh + ":" + mm + ":" + ss;// + mmss;				}else if (mm_ss){					tc = mm + ":" + ss;					//trace("  mm" + mm + " ss" + ss +" :::: "+tc);				}else{					tc = mm + ":" + ss + mmss;				}			}else{				console.warn("toTimeCode failed: "+pos+" ::"+Number(pos))				return "0:00";			}			return tc;		}	}}